### 1.分析是否为背包问题。

  1组合问题：dp[i] += dp[i-num]
    2True、False问题：dp[i] = dp[i] or dp[i-num]
    3最大最小问题公式：dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)

### 2.是以上三种背包问题中的哪一种。

### 3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。

### 4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。









# 01背包问题

```java
public class yym12 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int m = sc.nextInt();//容量
        int n=sc.nextInt();//个数
		int[] v = new int[n+1]; //价值
		int[] w = new int[n+1];//重量
		for (int i = 1; i < =n; i++)
			w[i] = sc.nextInt();
		for (int i = 1; i < =n; i++)
			v[i] = sc.nextInt();
		int[][] dp = new int[n+1][m + 1]; //dp[i][j] i表示第几个物品 j表示容量  数组结果表示最优价值
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (w[i] > j)
					dp[i][j] = dp[i - 1][j];//无法取
				else
					dp[i][j] = Math.max(dp[i - 1][j], v[i] + dp[i - 1][j - w[i]]);//不取，取

			}
		}
		System.out.println(dp[n][m]);
	}
}

//一维数组
```

![image-20231104170332529](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231104170332529.png)

### ![image-20231104170442786](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231104170442786.png)一、完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

#### 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。内外循环可以颠倒

```java
这个是组合且不排序
————————————————
  
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

//518    一、三重循环复杂度高
class Solution {
    public int change(int amount, int[] coins) {
        int n=coins.length;
        int[][]dp=new int[n+1][amount+1];
        dp[0][0]=1;	//重点
        for(int i=1;i<=n;i++){//n种
            for(int j=0;j<=amount;j++){//总钱数
                for(int k=0;k*coins[i-1]<=j;k++){//取几次
                    dp[i][j]+=dp[i-1][j-k*coins[i-1]];
                }
            }
        }
    return dp[n][amount];

    }
}
/////二、二重循环
class Solution {
    public int change(int amount, int[] coins) {
        int n=coins.length;
        int[][]dp=new int[n+1][amount+1];
       dp[0][0]=1;
       for(int i=1;i<=n;i++){ //个数
           for(int j=0;j<=amount;j++){//总重量
            dp[i][j]=dp[i-1][j];		//先都不选   //这是和01背包的区别
                if(j>=coins[i-1])dp[i][j]+=dp[i][j-coins[i-1]];    //如果能选就选
           }
       }
    return dp[n][amount];

    }
}
////三、一维数组
class Solution {
    public int change(int amount, int[] coins) {
        int n=coins.length;
        int[]dp=new int[amount+1];
       dp[0]=1;
      for(int i=1;i<=n;i++){
          for(int j=coins[i-1];j<=amount;j++){
              dp[j]+=dp[j-coins[i-1]];
          }
      }
    return dp[amount];

    }
}
```

```java
这是组合且排序
    
class Solution { //377	
    public int combinationSum4(int[] nums, int target) {
        int n=target;
        int dp[][]=new int[n+1][target+1];
dp[0][0]=1;
int ans=0;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=target;j++){
                for(int u:nums){
                   if(j>=u) dp[i][j]+=dp[i-1][j-u];
                }
            }
            ans+=dp[i][target];
        }
        return ans;
    }
}
```

```java
//416  TRue or false
public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        boolean[][] dp = new boolean[len][target + 1];
        
        // 初始化成为 true 虽然不符合状态定义，但是从状态转移来说是完全可以的
        dp[0][0] = true;

        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {.
                dp[i][j] = dp[i - 1][j];
                if (nums[i] <= j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }

            // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
            if (dp[i][target]) {
                return true;
            }
        }
        return dp[len - 1][target];
    }
}

```

# 二、多重背包问题

```java
朴素方法
    
    for(int i=1;i<=n;i++){
for(int j=0;j<=m;j++){
    for(int k=0;k<=s[i]&&k*w[i]<=j;k++){
        dp[i][j]=max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i])
    }
}
    }

二进制优化
    
      cin>>n>>m;
    int cnt=1;
    for(int i=1;i<=n;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);//c每件物品的个数
        int k=1;
        //进行 “打包” 转换：二进制优化，转换成01背包
        while(k<c)
        {
            v[cnt]=k*a,w[cnt++]=k*b;
            c-=k;
            k*=2;
        }
        if(c>0)
            v[cnt]=c*a,w[cnt++]=c*b;
    }
    //利用01背包中的空间优化模板求解。
    for(int i=1;i<=cnt;i++)
        for(int j=m;j>=v[i];j--)
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);}}

```

![image-20231210101149064](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231210101149064.png)
