```java
j/min要大于 j%min

//简称取平均向上取整。
(j + min) / (min + 1) 的值表示在给定的整数基数 j 下，可以形成多少个完整的组，同时确保每个组的大小不小于 min 个整数。这是为了确保在分组时尽可能均匀地利用整数，并考虑到可能存在的余数。
    每组min个数，一共j个数，平均分组数，每组相差不超过1.所得最小组数。
    
    
    //上面的貌似不准确
    向上取整：(int)Math.ceil((double)x/y);
	或者 （x+y-1）/y；化简得 (x-1)/y +1;
```

```java
充分利用自增自减
    i=0 flag=-1;
       if(i == 0 || i == n -1) flag = - flag;
            i += flag;

排序成N字行。
```

```java
数字翻转
    int res=0;
int last=0;
    while(x!=0){
        int temp=x%10;
        last=res;
        res=res*10+temp;
         //判断整数溢出
          if(last != res/10)
            {
                return 0;
            }
        x/=10;
    }

```

```java
看到与数字有关的，先看看能不能排序
    求多个数字和，考虑双指针，用while左右自增自减
    
```

```java
这里解释一下为什么要在head前创建一个新的节点，这样做可以避免讨论头结点被删除的情况，不管原来的head有没有被删除，直接返回dummy.next即可
    
    设计到头指针，就搞一个新的哑节点
```

```java
旋转图像考虑 水平翻转，沿对角线翻转
```

```java
"ate""eat""tae" 像这种字符的排序乱了可以先给他排好序；
    特点 字母一样，长度相同
    
    
    class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);//给字符串排序
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}

```

```java
将二维数组
    int[][] intervals = {{3, 5}, {1, 2}, {6, 4}, {2, 7}};
排序后
    int[][] intervals = {{1, 2}, {2, 7}, {3, 5}, {6, 4}};
Arrays.sort(intervals, new Comparator<int[]>() {
    @Override
    public int compare(int[] v1, int[] v2) {
        return v1[0] - v2[0];
    }
});  //这是完整版
简化版 Arrays.sotr(intervals,(v1,v2)->v1[0]-v2[0]);




List<int[]> ans = new ArrayList<>();

// 将people数组按照第二个元素进行排序
Arrays.sort(people, (a, b) -> Integer.compare(a[1], b[1]));

// 遍历排序后的数组，将其添加到ans列表
for (int[] person : people) {
    ans.add(person);
}
///////////////////////////////////////////////////////////////
ArrayList<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Cherry");

String[] arr = list.toArray(new String[0]);//将集合转为数组


```

```java
//用此for循环可以把一维数组直接加入到二维
class Solution {
    public int[][] merge(int[][] intervals) {
Arrays.sort(intervals,(v1,v2)->v1[0]-v2[0]);
int res[][]=new int [intervals.length][2];
int idx=-1;
for(int [] i: intervals){
    //如果数组为空或者数组前大于后，不用合并
    if(idx==-1||i[0]>res[idx][1]){
        res[++idx]=i;
    }else{
        res[idx][1]=Math.max(res[idx][1],i[1]);
    }
}
return Arrays.copyOf(res,idx+1);
    }
}
```

```java
求超大数的基本运算可以用数组 50！为例  太妙了
    
    public static void main(String[] args) {
	//计算阶乘 使用数组来储存
	int arr[]=new int [100];//100位,从右向左是个十百千。
	//例如512*34；将512大数存到数组中5 1 2分别每一位*34； 从个位开始每位/10；余数留下，除数进位。
	//将34小数设为num；、
	arr[arr.length-1]=1;//乘数
	int num=50;
	for(int i=1;i<=num;i++) {
		arr=mm(arr,i);
	}
for(int i:arr) {
	System.out.print(i);
}
	
}
static int[] mm(int shu[],int num) {
	
	for(int i=0;i<shu.length;i++) {
		shu[i]=shu[i]*num;
	}
	for(int i=shu.length-1;i>0;i--) {
		
		shu[i-1]+=shu[i]/10;//进位
		shu[i]%=10;//余数留
	}
	return shu;
}
```

![image-20231028194452730](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231028194452730.png)

```java
标记法！
如果说里面有的数据想删除或替换重复了不方便，可以用布尔数组，先标记一下。
```

```java
求n的阶乘尾数0的个数，实际上就是求2*5==10才会有0，求2和5的匹配个数，2显然比5多，只需求5就行，是乘法因子里面有多少个5
    
    
     public int trailingZeroes(int n) {
        int ans = 0;
        while (n != 0) {
            n /= 5;
            ans += n;
        }
        return ans;
    }
```

```java
求pow（x,n）			
    while(n>0){
        int res=1;
        if(n%2==1){		//将n用二进制表示，每位如果是1就计入贡献
            res*=x;			//例n=77  1 2 4 9 19 38 77   (从77到38额外贡献了1个x)(从19到9也贡献了一个x，但之后被平方了2次)一直到最初的x被平方了6次
             						        1 1     1
                                          x*x4*x8*x64=x77=res
        }
        x*=x; //贡献不断平方
        n/=2;
    }
```

```java
class Solution { //组合排序100136
    long inf=1000000007L;
    public int numberOfGoodPartitions(int[] nums) {
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            map.put(nums[i],i);
        }
        int ne=0;
        int shu=1;
        for(int i=0;i<nums.length;i++){
            if(i>ne){
                shu++;
            }
            ne=Math.max(ne,map.get(nums[i]));
        }
return mm(2,shu-1);

    }
    int mm(long x,long y){
        long res=1;
        while(y>0){
            if(y%2==1){
                res=res*x%inf;
            }
            x=x*x%inf;
            y/=2;
        }
        return (int)res;
    }
}
```

```java
class Solution {//最近回文字符串  564；
    public String nearestPalindromic(String n) {
            int len=n.length();
        long cur=Long.parseLong(n);
        Set<Long> set=new HashSet<>();

        set.add((long)Math.pow(10,len-1)-1);
        set.add((long)Math.pow(10,len)+1);

        long t=Long.parseLong(n.substring(0,(len+1)/2));

        for(long i=t-1;i<=t+1;i++){
            long temp =getNum(i,len%2==0);
            if(temp!=cur){
                set.add(temp);
            }
        }
        long ans=-1;
        for(long i:set){
            if(ans==-1){ans=i;}
        else if(Math.abs(i-cur)<Math.abs(ans-cur))
        ans=i;
           else if(Math.abs(i-cur) == Math.abs(ans - cur) && i < ans)
                ans = i;
        }
        //将结果转换为字符串返回
        return String.valueOf(ans);
    }

    long getNum(long k,boolean isEven){
        StringBuffer sb=new StringBuffer();
        sb.append(k);
        int n=sb.length(),idx=isEven?n-1:n-2;
        while(idx>=0){
            sb.append(sb.charAt(idx--));
        }
        return Long.parseLong(sb.toString());
    }
}
```

三角形面积公式：

```java
double a=sc.nextDouble();
double b=sc.nextDouble();
double c=sc.nextDouble();
double p=(a+b+c)/2;
System.out.printf("%.1f",Math.sqrt(p*(p-a)*(p-b)*(p-c)));
```



```java

```

