```java
//入度与出度   有向图
class Solution {
    public int findJudge(int n, int[][] trust) {
       int [] in=new int [n+1];
       int [] out=new int [n+1];
       for(int ar[]: trust){
           in[ar[1]]++;
           out[ar[0]]++;
       }
```

并查集是一种数据结构
并查集这三个字，一个字代表一个意思。
并（Union），代表合并
查（Find），代表查找
集（Set），代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素
并查集的典型应用是有关连通分量的问题
并查集解决单个问题（添加，合并，查找）的时间复杂度都是O(1)O(1)O(1)
因此，并查集可以应用到在线算法中



```java



找有几个划分，还是递归，也可以用并查集
    class Solution {
    public int findCircleNum(int[][] isConnected) {
int n=isConnected.length;
int sum=0;
boolean [] visited =new boolean [n];
for(int i=0;i<n;i++){
    if(!visited[i]){
        dfs(isConnected,visited,n,i);
        sum++;
    }
}
return sum;
    }
    public void dfs(int [][] isConnected, boolean [] visited,int n,int i){
        for(int j=0;j<n;j++){
            if(isConnected[i][j]==1&&!visited[j]){
                visited[j]=true;
                dfs(isConnected,visited,n,j);
            }
        }
    }
}
//一个矩阵 如图 巧妙递归，找出一个个相连的城市

```

![image-20230720094414910](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230720094414910.png)

```java
//并查集的模板 一般是数组arr[][2],谁和谁有联系，我们可以把他当作寻找父节点，一个个串起来。
//适用于无向图

就是将两者之间有关系的，随便找一个当作祖先，把有关系的一个个都union起来。然后最后你在打印一遍parent【i]=i
    如果还等的话，就说明他是一个独立的，把所有这样=i的加起来，就是多少种不同的XX。

class Solution {
		public boolean validPath(int n, int[][] edges, int source, int destination) {
			int parent[] = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
			}
			boolean sd = false;
			for (int i = 0; i < edges.length; i++) {
				union(parent, edges[i][0], edges[i][1]);
			}
			return find(parent, source) == find(parent, destination);
		}

		public int find(int parent[], int index) {
			if (parent[index] != index) {
				parent[index] = find(parent, parent[index]);
			}
			return parent[index];
		}

		public void union(int parent[], int index1, int index2) {
			parent[find(parent, index1)] = find(parent, index2);

		}
	}
```

单源路径 迪杰斯特拉  给定某点，求到另一点的最短距离

```java
class Solution {//743   //1976
  
    public int networkDelayTime(int[][] times, int n, int k) {
       int INF=Integer.MAX_VALUE/2;

       //邻接矩阵储边信息
       int[][]g=new int[n][n];
       for(int i=0;i<n;i++){
           Arrays.fill(g[i],INF);
       }	
       for(int[] t:times){
           int x=t[0]-1,y=t[1]-1;
           g[x][y]=t[2];
       }
        
        //从源点到某点的距离数组
        int[] dist=new int [n];
        Arrays.fill(dist,INF);
        dist[k-1]=0;


        //节点是否被更新数组
        boolean [] used=new boolean[n];

        for(int i=0;i<n;i++){
            //未确定最短路的点中，寻找距离最小的点
            int x=-1;
            for(int y=0;y<n;y++){
                if(!used[y]&&(x==-1||dist[y]<dist[x])){
                    x=y;
                }
            }

            //用该点更新所有其他点的距离
            used[x]=true;
            for(int y=0;y<n;y++){
                dist[y]=Math.min(dist[y],dist[x]+g[x][y]);
            }
        }
        int ans=Arrays.stream(dist).max().getAsInt();
return ans==INF?-1:ans;
    }
}
```

最短路径之 Floyd 算法  求的是任意两点之间的最短距离 //1334

```java
public class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] w = new int[n][n];
        for (int[] row : w) {
            Arrays.fill(row, Integer.MAX_VALUE / 2); // 防止加法溢出
        }
        for (int[] e : edges) {
            int x = e[0], y = e[1], wt = e[2];
            w[x][y] = w[y][x] = wt;
        }
        int[][][] memo = new int[n][n][n];

        int ans = 0;
        int minCnt = n;
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (j != i && dfs(n - 1, i, j, memo, w) <= distanceThreshold) {
                    cnt++;
                }
            }
            if (cnt <= minCnt) { // 相等时取最大的 i
                minCnt = cnt;
                ans = i;
            }
        }
        return ans;
    }

    private int dfs(int k, int i, int j, int[][][] memo, int[][] w) {
        if (k < 0) { // 递归边界
            return w[i][j];
        }
        if (memo[k][i][j] != 0) { // 之前计算过
            return memo[k][i][j];
        }
        return memo[k][i][j] = Math.min(dfs(k - 1, i, j, memo, w),
                dfs(k - 1, i, k, memo, w) + dfs(k - 1, k, j, memo, w));
    }
}   

/////////////////////////////////////////下面才是真正的floyd算法
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int [][]g=new int [n][n];
      for(int i=0;i<n;i++){
          for(int j=0;j<n;j++){
              g[i][j]=i==j?0:Integer.MAX_VALUE/2;
          }
      }

        for(int [] e: edges){
            int x=e[0],y=e[1],wt=e[2];
            g[x][y]=g[y][x]=Math.min(g[x][y],wt);
        }
        floyd(g);
int ans=-1,cnt=n;
for(int i=0;i<n;i++){
    int cur=0;
    for(int j=0;j<n;j++){
        if(i!=j&&g[i][j]<=distanceThreshold)cur++;
    }
    if(cur<=cnt){
        cnt=cur;
        ans=i;
    }
}
return ans;
    }
    void floyd(int[][] g){
        int n=g.length;

        for(int p=0;p<n;p++){
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    g[i][j]=Math.min(g[i][j],g[i][p]+g[p][j]);
                }
            }
        }

    }

}
```

```java
贡献度 也挺经典//2477  到达首都的最少油耗

    
```

